method:1(without recursion ,using level order traversal)
Tc:o(n^2)
---------------
int height(tree* root)
{
if(root==NULL)return 0;
else{
int lh=height(root->left);
int rh=height(root->right);
return max(lh,rh)+1;
}
}
int level(Tree *root)
{
if(!root)return 0;
queue<tree*>q;
q.push(root);
while(!q.empty())
{
tree* t=q.front();
int lh=height(t->left);
int rh=height(t->right);
if(abs(lh-rh)>=2)
return 0;
if(t->left)q.push(t->left);
if(t->right)q.push(t->right);
}
return 1;
}
-------------------------------------------------------------------
method:1a
without recursion and o(n) possible only if change struct into
struct tree{
int data;
int lh,rh;
tree *lc;
tree *rc;
};
and using post order traversal;

---------------------------------------------------------------

method:2(using recursion with o(n))(prefered)
bool isBalanced(node* root, int* height) 
{ 
  
    /* lh --> Height of left subtree  
    rh --> Height of right subtree */
    int lh = 0, rh = 0; 
  
    /* l will be true if left subtree is balanced  
    and r will be true if right subtree is balanced */
    int l = 0, r = 0; 
  
    if (root == NULL) { 
        *height = 0; 
        return 1; 
    } 
  
    /* Get the heights of left and right subtrees in lh and rh  
    And store the returned values in l and r */
    l = isBalanced(root->left, &lh); 
    r = isBalanced(root->right, &rh); 
  
    /* Height of current node is max of heights of left and  
    right subtrees plus 1*/
    *height = (lh > rh ? lh : rh) + 1; 
  
    /* If difference between heights of left and right  
    subtrees is more than 2 then this node is not balanced  
    so return 0 */
    if (abs(lh -rh) >= 2) 
        return 0; 
  
    /* If this node is balanced and left and right subtrees  
    are balanced then return true */
    else
        return l && r; 
} 
