Effective approach:
--------------
// Iterative C++ program to reverse 
// a linked list 
#include <iostream> 
using namespace std; 

/* Link list node */
class Node { 
	public:	
	int data; 
	 Node* next,*prev,*head;

		Node()
		{
			head=NULL;
		}
	Node(int data) 
	{ 
		this->data = data; 
		next = NULL; 
		prev=NULL;
	} 
		void push(int data) 
	{ 
		Node* temp = new Node(data); 
	if(head==NULL)
	{
		head=temp;
	}
	else
	{
		Node *trav=head;
		while(trav&&trav->next)
		{
			trav=trav->next;
		}
		trav->next=temp;
		temp->prev=trav;
	}
	} 
		void print() 
	{ 
		 Node* temp = head; 
		while (temp != NULL) { 
			cout << temp->data << " "; 
			temp = temp->next; 
		} 
	} 
}; 



/* Driver program to test above function*/
int main() 
{ 
	/* Start with the empty list */
	Node ll; 
	ll.push(20); 
	ll.push(4); 
	ll.push(15); 
	ll.push(85); 

	cout << "Given linked list\n"; 
	ll.print(); 
cout<<ll.head->data<<endl;

	return 0; 
} 
--------------------------------------------------------------------------


// C++ program to delete a linked list 
#include <bits/stdc++.h> 
using namespace std; 

/* Link list node */
class Node 
{ 
	public: 
	int data; 
	Node* next; 
}; 

/* Function to delete the entire linked list */
void deleteList(Node** head_ref) 
{ 
	
/* deref head_ref to get the real head */
Node* current = *head_ref; 
Node* next; 

while (current != NULL) 
{ 
	next = current->next; 
	free(current); 
	current = next; 
} 
	
/* deref head_ref to affect the real head back 
	in the caller. */
*head_ref = NULL; 
} 

/* Given a reference (pointer to pointer) to the head 
of a list and an int, push a new node on the front 
of the list. */
void push(Node** head_ref, int new_data) 
{ 
	/* allocate node */
	Node* new_node = new Node(); 

	/* put in the data */
	new_node->data = new_data; 
	
	/* link the old list off the new node */
	new_node->next = (*head_ref); 
	
	/* move the head to point to the new node */
	(*head_ref) = new_node; 
} 

/* Driver code*/
int main() 
{ 
	/* Start with the empty list */
	Node* head = NULL; 
	
	/* Use push() to construct below list 
	1->12->1->4->1 */
	push(&head, 1); 
	push(&head, 4); 
	push(&head, 1); 
	push(&head, 12); 
	push(&head, 1); 
	
	cout << "Deleting linked list"; 
	deleteList(&head); 
	
	cout << "\nLinked list deleted"; 
} 

// This is code is contributed by rathbhupendra 
----------------------------------------------------------
// C++ program to delete a node from 
// Doubly Linked List 
#include <bits/stdc++.h> 
using namespace std; 

/* a node of the doubly linked list */
class Node 
{ 
	public: 
	int data; 
	Node* next; 
	Node* prev; 
}; 

void deleteNode(Node** head_ref, Node* del) 
{ 
	/* base case */
	if (*head_ref == NULL || del == NULL) 
		return; 

	/* If node to be deleted is head node */
	if (*head_ref == del) 
		*head_ref = del->next; 

	/* Change next only if node to be 
	deleted is NOT the last node */
	if (del->next != NULL) 
		del->next->prev = del->prev; 

	/* Change prev only if node to be 
	deleted is NOT the first node */
	if (del->prev != NULL) 
		del->prev->next = del->next; 

	/* Finally, free the memory occupied by del*/
	free(del); 
	return; 
} 

void push(Node** head_ref, int new_data) 
{ 

	Node* new_node = new Node(); 

	new_node->data = new_data;

	new_node->prev = NULL; 
	new_node->next = (*head_ref); 
	if ((*head_ref) != NULL) 
		(*head_ref)->prev = new_node; 
	(*head_ref) = new_node; 
} 
void printList(Node* node) 
{ 
	while (node != NULL) 
	{ 
		cout << node->data << " "; 
		node = node->next; 
	} 
} 

/* Driver code*/
int main() 
{ 
	/* Start with the empty list */
	Node* head = NULL; 

	/* Let us create the doubly linked list 10<->8<->4<->2 */
	push(&head, 2); 
	push(&head, 4); 
	push(&head, 8); 
	push(&head, 10); 

	cout << "Original Linked list "; 
	printList(head); 
	deleteNode(&head, head); /*delete first node*/
	deleteNode(&head, head->next); /*delete middle node*/
	deleteNode(&head, head->next); /*delete last node*/
	cout << "\nModified Linked list "; 
	printList(head); 

	return 0; 
} 

